# 创建型设计模式

<table  style="width: 1000px;  ">
    <tr>
        <td width=10%  > 类型  </td>
        <td width=10% >模式名称</td>
        <td width=10% > 学习难度</td>
        <td width=10% > 使用频率</td>
    </tr>
    <tr>
        <td rowspan="7">创建型模式  <br> Creational Pattern </td>
    </tr>
    <tr>
        <td>单例模式 <br>  Singleton Pattern  </td>
        <td> <font color=red >★☆☆☆☆</font></td>
        <td> <font color=red >★★★★☆</td>
    </tr>
     <tr>
            <td>简单工厂模式  <br>  Simple Factory Pattern  </td>
            <td> <font color=red > ★★☆☆☆</td>
            <td> <font color=red >★★★☆☆</td>
     </tr>
<tr>
        <td>工厂方法模式 <br>  Factory Method Pattern  </td>
        <td> <font color=red > ★★☆☆☆</td>
        <td> <font color=red >★★★★★</td>
    </tr>
 <tr>
        <td>抽象工厂模式 <br>  Abstract Factory Pattern  </td>
        <td> <font color=red > ★★★★☆</td>
        <td> <font color=red >★★★★★</td>
    </tr>
 <tr>
        <td>原型模式 <br>  Prototype Pattern  </td>
        <td> <font color=red > ★★★☆☆</td>
        <td> <font color=red >★★★☆☆</td>
    </tr>
 <tr>
        <td>建造者模式 <br>  Builder Pattern  </td>
        <td> <font color=red > ★★★★☆</td>
        <td> <font color=red >★★☆☆☆</td>
    </tr>
</table>



### 单例模式(Singleton Pattern)：
  确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。  
  
  单例模式有三个要点：
  一是某个类只能有一个实例；  
  二是它必须自行创建这个实例；  
  三是它必须自行向整个系统提供这个实例。  
  单例模式是结构最简单的设计模式一，在它的核心结构中只包含一个被称为单例类的特殊类  
  
    
    饿汉式单例类与懒汉式单例类比较
    
          饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。
    
          懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。
   
---


### 简单工厂模式(Simple Factory Pattern)：
  定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。
  
   在简单工厂模式结构图中包含如下几个角色：
  
         ● Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。
  
         ● Actor（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。
  
         ● ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。


---

### 工厂方法模式(Factory Method Pattern)：
 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式。
  
   在工厂方法模式结构图中包含如下几个角色：
  
         ● Actor（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
  
         ● ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
  
         ● Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
  
         ● ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。
  
         与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类



---


###   抽象工厂模式(Abstract Factory Pattern)：
 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。  
 
 
    在抽象工厂模式结构图中包含如下几个角色：
 
        ● AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
 
        ● ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
 
        ● AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。
 
        ● ConcreteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。
 
        在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，


 ---
 
   
###   原型模式(Prototype  Pattern)：  
   使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。  
     
     
在原型模式结构图中包含如下几个角色:
   
         ●Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。
   
         ● ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。
   
         ● Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，  
   再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，  
   系统具有较好的可扩展性，增加或更换具体原型类都很方便。
   
         原型模式的核心在于如何实现克隆方法，下面将介绍两种在Java语言中常用的克隆实现方法
   
   
   ---
   
    
### 建造者模式(Builder Pattern)：  
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。
   
     在建造者模式结构图中包含如下几个角色：
   
   ● Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。
   
   ●ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
   
   ●Actor（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。
   
   ● Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。
   
         在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件
   
   
   ---
